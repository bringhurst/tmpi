# ifndef _NETD_COMM_H_
# define _NETD_COMM_H_
/**
 * Header file for simple communications
 * supported by the network device
 * (P4 or TCP/IP or maybe something else
 *
 * All node addresses (from, to, root) 
 * are the cluster node ID and not thread node
 * ID.
 */

# define NETD_OP_ABSMAX 1
# define NETD_OP_ABSMIN 2
# define NETD_OP_MAX 3
# define NETD_OP_MIN 4
# define NETD_OP_MULT 5
# define NETD_OP_SUM 6

/** note that NETD_CHR is not valid reduce type */
# define NETD_TYPE_INT 1
# define NETD_TYPE_FLT 2
# define NETD_TYPE_DBL 3
# define NETD_TYPE_LNG 4
# define NETD_TYPE_CHR 5

/** if you wants to define new types, start from NETD_NXT **/
# define NETD_TYPE_NXT 100

# define MAX_MSG_DEFAULT 1024

/** set the maximum message size **/
int netd_setMsgSize(int msgsize);

/** get the maximum message size **/
int netd_getMsgSize();

/** always use user provided buffer **/
int netd_sendmsg(int to, char *msg, int len);
int netd_senddat(int to, char *data, int len);
int netd_sendmsgdat(int to, char *msg, int msglen, char *data, int datlen);

/**
 * receive a message envelop of size up to "size" bytes and call msg_handle
 * with the real data and length, the buffer passed to the handle is
 * volatile and should not be accessed after the handle returns
 *
 * the return code from the msg_handle is stored into status if status is 
 * not NULL (in that case, netd_recvmsg itself will return 0); otherwise,
 * the return code of the msg_handle is returned.
 *
 * We strongly suggest the usage of status, because otherwise, one cannot
 * distinguish whether the return code is generated by netd_recvmsg itself
 * or by msg_handle. 
 *
 * If one choose not to provide a status pointer, he should avoid -1 as the
 * return code of msg_handle (which is the error code for netd_recvmsg()). 
 * To make sure his program is compatible with future releases, one should
 * set return code for errors <(less than) -1024. Also, it is a good 
 * idea to return 0 upon success (which coincides with the successful return 
 * code when the status pointer is provided).
 *
 * The meaning of result is interpreted by the msg_handle. It does have the
 * choice to ignore the result. It will mainly be used for msg_handle to 
 * communication with the outside world. (IN, OUT or IN/OUT)
 */
int netd_recvmsg(
		int size, 
		int (*msg_handle)(int from, char *data, int len, void **result), 
		void **result, 
		int *status
	);

/** receive the data to the user provided buffer **/
int netd_recvdat(int from, char *data, int len);

/** group communication **/
int netd_bcast(char *data, int len, int root);
/* the reduce and allreduce might change the src buffer! */
int netd_reduce(char *src, char *result, int nelem, int op, int data_type, int root);
int netd_allreduce(char *src, char *result, int nelem, int op, int data_type);

/** probe message **/
int netd_canSendMsg(int to);
int netd_canRecvMsg(int from);

/** probe data **/
int netd_canSendDat(int to);
int netd_canRecvDat(int from);

/** barrier **/
int netd_barrier();

typedef struct netd_group NETD_GROUP;
/* everybody should initialize the group with ids in the same order */
int netd_init_group(int *ids, int count, NETD_GROUP *group);
int netd_bcast_group(char *data, int len, int root, NETD_GROUP *group);
int netd_reduce_group(char *src, char *result, int nelem, int op, int data_type, 
		int root, NETD_GROUP *group);
int netd_allreduce_group(char *src, char *result, int nelem, int op, int data_type, NETD_GROUP *group);
int netd_barrier_group(NETD_GROUP *group);
int netd_destroy_group(int *ids, int count, NETD_GROUP *group);

/* debug functions */
void netd_dump_hcube(int root);
# endif
